chromium-bsu

# Chromium B.S.U. 0.9.15.1-1, Ubuntu Linux 14.04, 64 bit, PIE
#
# +3 Trainer: Lives, Shields, Ammo
#
# Maintainer: Sebastian Parschauer <s.parschauer@gmx.de>
#
# https://www.youtube.com/watch?v=mTpC30tSMqU
#
# adaption too difficult - pointer following is unpreferred
#
# This is a pointer following example from static memory to
# a single dynamic memory object - same method as in
# Cheat Engine.


define LIVES_CHECK check 0xbc i32 g 0


ptrmemstart HeroAircraft 288

Lives 0xbc i32 l 9 1,0 a
LIVES_CHECK
Damage 0xec f32 g -500.0 2,0 a
LIVES_CHECK
Shield 0xf0 f32 l 1000.0 2,0 a
LIVES_CHECK

Ammo_1 0xd0 f32 l 150.0 3,0 a
Ammo_2 0xd4 f32 l 150.0 3,0 a
Ammo_3 0xd8 f32 l 150.0 3,0 a
Ammo_1_en 0x58 u8 l 1 3,0 a
Ammo_2_en 0x59 u8 l 1 3,0 a
Ammo_3_en 0x5a u8 l 1 3,0 a

ptrmemend


# Pointer in static memory pointing to the
# HeroAircraft object on the heap, PIE is used
HeroAircraftPtr 0x2578c0 p HeroAircraft always
# check for valid PIE heap pointer with kernel 3.13/3.16
check HeroAircraftPtr u64 g 0x7f0000000000




# Discovery is also cumbersome and requires a gdb watchpoint and disassembly.
# But the size of the object remains hidden.

# Discovery example on openSUSE without PIE:
#
# $ scanmem -p `pidof chromium-bsu`
# # find the number of lives
# 1> list
# [ 0]      1d0904c,  2 +       44004c,  heap, 4, [I64 I32 I16 I8 ]
# 1> set 0=9
# info: setting *0x1d0904c to 0x9...
#
# $ gdb -p `pidof chromium-bsu`
# (gdb) watch *0x1d0904c
# Hardware watchpoint 1: *0x1d0904c
# (gdb) cont
# Continuing.
# Thread 1 "chromium-bsu" hit Hardware watchpoint 1: *0x1d0904c
# Old value = 9
# New value = 8
# 0x0000000000415d64 in HeroAircraft::loseLife() ()
# (gdb) disassemble
# Dump of assembler code for function _ZN12HeroAircraft8loseLifeEv:
#    0x0000000000415d30 <+0>:	push   %rbx
#    0x0000000000415d31 <+1>:	mov    %rdi,%rbx
#    0x0000000000415d34 <+4>:	sub    $0x10,%rsp
#    0x0000000000415d38 <+8>:	mov    0xbc(%rdi),%eax
#    0x0000000000415d3e <+14>:	mov    0x23d51b(%rip),%rdx        # 0x653260 <_ZN6Global4heroE>
#    0x0000000000415d45 <+21>:	movl   $0x41233333,(%rsp)
#    0x0000000000415d4c <+28>:	movl   $0x41c80000,0x8(%rsp)
#    0x0000000000415d54 <+36>:	sub    $0x1,%eax
#    0x0000000000415d57 <+39>:	cvtsi2ss %eax,%xmm0
#    0x0000000000415d5b <+43>:	cmp    $0xffffffff,%eax
#    0x0000000000415d5e <+46>:	mov    %eax,0xbc(%rdi)
# => 0x0000000000415d64 <+52>:	mulss  0x6c(%rdx),%xmm0

# The important operation here is "mov    %eax,0xbc(%rdi)"
# one line above the marker.
# The address of the HeroAircraft object is located in CPU register RDI.
# The lives are at offset 0xbc. So we need to look for a pointer pointing
# to 0x1d0904c - 0xbc = 0x1d08f90.
#
# (gdb) info registers
# ...
# rdi            0x1d08f90	30445456
# ...
#
# 1> reset
# 0> option scan_data_type int64
# 0> lregions
# 0> dregion !0,1
# 0> lregions
# [ 0]       62f000,  147456 bytes,   exe,       400000, rw-, /usr/bin/chromium-bsu
# [ 1]       653000,    4096 bytes,   exe,       400000, rw-, unassociated
# 0> 0x1d08f90
# 1> list
# [ 0]       653260,  1 +       253260,   exe, 30445456, [I64 ]
#
# We are lucky here that we have a single match. The variable at static
# memory address 0x653260 contains the current address of the HeroAircraft
# object. Further values can be discovered by guessing the object size,
# dumping the pointer memory in two states, and comparing them.
